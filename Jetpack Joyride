from cmu_graphics import *
import math,copy
import random
#from PIL import Image
#import os, pathlib

##scaffolding for game function
def onAppStart(app):
    app.BestDistance=0
    app.distance=0
    app.totalCoins=0
    app.gameOver=False
    app.inMenus=False
    #app.menuScreen=image
    app.inShop=False
    #app.shopScreen=image
    app.inGadgetShop=False
    #app.gadgetScreen=image
    app.inJetpackSkinShop=False
    #app.jetpackSkinScreen=image
    app.playing=True
    #app.playingScreen=image
    app.stepsPerSecond=10
    app.width=900
    app.divisor=30
    app.height=(app.width//2)
    app.boardWidth=(app.width*4)//3
    app.boardHeight=(app.height*9)//10
    app.rows=app.boardHeight//app.divisor
    app.cols=app.boardWidth//app.divisor
    app.boardLeft=0
    app.boardTop=(app.height-app.boardHeight)//2
    app.cellBorderWidth=2
    app.board=[([None]*app.cols) for row in range(app.rows)]
    app.steps=0
    app.zapperList=[]
    app.missileList=[]
    app.playerCx=(app.boardWidth//app.cols)*4
    app.playerCy=app.boardTop+(app.boardHeight-(app.boardHeight//app.rows))
    app.playerRadius=(((app.boardHeight//app.rows)*2)//3)
    app.dy=0
    app.d2y=2.5
    #acceleration
    app.boosting=False
    #if the character is on the ground
    app.grounded=True
    #if the character hits the ceiling
    app.ceilinged=False
    #if the character hits and obstacle
    app.gameOver=False

def onMousePress(app,mouseX,mouseY):
    if app.inMenus==True:
        pass
        #if mouse is within shopIcon
            #app.inMenus=False
            #app.inShop=True
        #elif mouse is within playGameIcon
            #app.inMenus=False
            #app.playing=True
    elif app.inShop==True:
        pass
        #if mouse is withing gadgetShopIcon
            #app.inShop=False
            #app.inGadgetShop=True
        #elif mouse is within jetpackSkinShopIcon
            #app.inShop=False
            #app.inJetpackSkinShop=True
    elif app.inGadgetShop==True:
        pass
    elif app.inJetpackSkinShop==True:
        pass
    else:
        pass
        #when app.playingScreen==True

def onKeyPress(app,key):
    if app.playing:
        if key=='space':
            app.grounded=False
            app.boosting=True
            #jetpack is on

def onKeyRelease(app,key):
    if app.playing:
        if key=='space':
            app.ceilinged=False
            app.boosting=False
            #jetpack is off

def onStep(app):
    if app.playing:
        #if app.gameOver=True:
            
            #while(app.steps)
        #check collisions:
        for row in range(app.rows):
            for col in range(app.cols):
                cellLeft,cellTop=getCellLeftTop(app,row,col)
                cellWidth,cellHeight=getCellSize(app)
                if ((app.board[row][col]!=None) and 
                    (distance(app.playerCx,app.playerCy,
                    cellLeft+(0.5*cellWidth),cellTop+(0.5*cellHeight))<
                    app.playerRadius+(0.5*cellWidth))):
                    app.gameOver=True

        #keeps the player inBounds
        if (app.playerCy+app.playerRadius+app.dy>app.boardTop+app.boardHeight):
            app.dy=0
            app.playerCy=app.boardTop+app.boardHeight-(app.playerRadius)
            app.grounded=True
        elif (app.playerCy-app.playerRadius+app.dy<app.boardTop):
            app.dy=0
            app.playerCy=app.boardTop+app.playerRadius
            app.ceilinged=True

        #moves the player
        if app.boosting:
            if (not app.ceilinged):
                app.dy-=app.d2y
        else:
            if (not app.grounded):
                app.dy+=app.d2y
        app.playerCy+=app.dy

        #move the screen, zappers, and missiles
        for zapper in app.zapperList:
            zapper.col-=1
        for zapper in app.zapperList:
            if (zapper.col+zapper.pixels<0):
                app.zapperList.remove(zapper)
        for missile in app.missileList:
            if missile.activated==True:
                missile.posX-=missile.speed
        for missile in app.missileList:
            if (missile.posX+missile.radius<0):
                app.missileList.remove(missile)
        #app.playingScreen to the left and loop image
        if app.steps%50==0:
            #addzapper to ZapperList
            addZapper(app)
        if app.steps%150==0:
            addMissile(app)
        #add steps and distance
        app.distance+=1
        app.steps+=1
    else:
        app.distance=0
        app.steps=0

def redrawAll(app):
    if app.gameOver:
        drawCircle(100,100,50,fill='red')
    drawBoard(app)
    drawPlayerHitbox(app)
    for zapper in app.zapperList:
        drawZapper(app,zapper.pixels,zapper.angle,zapper.heightRow,zapper.col)
    for missile in app.missileList:
        #length of delay
        if (app.steps-missile.time<40):
            drawMissileWarning(app,missile.radius)
        else:
            missile.activated=True
            drawMissile(missile.radius,missile.posX,missile.height)


#Obstacles***
#angles: 0=horizontal,1=45 degrees, 2=vertical, 3=135 degrees
#pixels: in range of (2*app.rows)//3? of app.rows--longer zappers are less likely?
#zappers
class zapper:
    def __init__(self,pixels,angle,heightRow,col):
        self.pixels=pixels
        self.angle=angle
        self.heightRow=heightRow
        self.col=col
    def __repr__(self):
        return f'col:{self.col},{self.pixels} pixels'

def drawZapper(app,pixels,angle,heightRow,col):
    if angle==0:
        for i in range (pixels):
            app.board[heightRow][col]='yellow'
            col+=1
        if(app.board[heightRow][col]=='yellow'):
            app.board[heightRow][col]=None
    elif angle==1:
        #to check make sure the zapper is in the board
        while ((heightRow-pixels)<-1):
            heightRow+=1
        for i in range(pixels):
            app.board[heightRow][col]='yellow'
            if(app.board[heightRow][col+1]=='yellow'):
                app.board[heightRow][col+1]=None
            heightRow-=1
            col+=1
    elif angle==2:
        #to check make sure the zapper is in the board
        while ((heightRow+pixels)>app.rows):
            heightRow-=1
        for i in range(pixels):
            app.board[heightRow][col]='yellow'
            if(app.board[heightRow][col+1]=='yellow'):
                app.board[heightRow][col+1]=None
            heightRow+=1
    elif angle==3:
        #to check make sure the zapper is in the board
        while ((heightRow+pixels)>app.rows):
            heightRow-=1
        for i in range(pixels):
            app.board[heightRow][col]='yellow'
            if(app.board[heightRow][col+1]=='yellow'):
                app.board[heightRow][col+1]=None
            heightRow+=1
            col+=1

def addZapper(app):
    randPixels=random.randrange(3,((app.rows)//2)+1)
    randAngle=random.randrange(4)
    randRowHeight=random.randrange(app.rows)
    initialCol=((app.cols*3)//4)
    app.zapperList.append(zapper(randPixels,randAngle,randRowHeight,initialCol))
##missiles
##0=small&fast,1=large&slow
class missile:
    def __init__(self,type,time,height,posX):
        self.time=time
        self.height=height
        self.posX=posX
        self.radius=10*type+20
        self.speed=40/(type+1)
        self.activated=False

def drawMissileWarning(app,radius):
    drawCircle(app.width-radius,app.playerCy,radius,fill=None,border='red')

def drawMissile(radius,posX,height):
    drawCircle(posX,height,radius,fill='red')
  
def addMissile(app):
    randType=random.randrange(2)
    app.missileList.append(missile(randType,app.steps,app.playerCy,app.width+50))

##player
def drawPlayerHitbox(app):
    drawCircle(app.playerCx,app.playerCy,app.playerRadius,border='black',fill=None)

#FROM CMU CS ACADEMY
def distance(x0, y0, x1, y1):
    return ((x1 - x0)**2 + (y1 - y0)**2)**0.5

def drawBoard(app):
    for row in range(app.rows):
        for col in range(app.cols):
            color = app.board[row][col]
            drawCell(app, row, col, color)

def drawCell(app, row, col, color):
    cellLeft, cellTop = getCellLeftTop(app, row, col)
    cellWidth, cellHeight = getCellSize(app)
    drawRect(cellLeft, cellTop, cellWidth, cellHeight,
             fill=color, border='lightGrey',
             borderWidth=app.cellBorderWidth)

def getCell(app, x, y):
    dx = x - app.boardLeft
    dy = y - app.boardTop
    cellWidth, cellHeight = getCellSize(app)
    row = math.floor(dy / cellHeight)
    col = math.floor(dx / cellWidth)
    if (0 <= row < app.rows) and (0 <= col < app.cols):
      return (row, col)
    else:
      return None

def getCellLeftTop(app, row, col):
    cellWidth, cellHeight = getCellSize(app)
    cellLeft = app.boardLeft + col * cellWidth
    cellTop = app.boardTop + row * cellHeight
    return (cellLeft, cellTop)

def getCellSize(app):
    cellWidth = app.boardWidth / app.cols
    cellHeight = app.boardHeight / app.rows
    return (cellWidth, cellHeight)

def drawBoard(app):
    for row in range(app.rows):
        for col in range(app.cols):
            color = app.board[row][col]
            drawCell(app, row, col,color)

def main():
    runApp()

if __name__=='__main__':
    main()